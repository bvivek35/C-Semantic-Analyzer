Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> var_decl
Rule 1     var_decl -> type ID SEMICOLON
Rule 2     var_decl -> type ID ASSIGN value SEMICOLON
Rule 3     type -> TYPE_INT
Rule 4     type -> TYPE_FLOAT
Rule 5     type -> TYPE_CHAR
Rule 6     type -> TYPE_DOUBLE
Rule 7     value -> INT
Rule 8     value -> FLOAT
Rule 9     value -> DOUBLE
Rule 10    value -> CHAR
Rule 11    value -> ID

Terminals, with rules where they appear

ASSIGN               : 2
CHAR                 : 10
DOUBLE               : 9
FLOAT                : 8
ID                   : 1 2 11
INT                  : 7
SEMICOLON            : 1 2
TYPE_CHAR            : 5
TYPE_DOUBLE          : 6
TYPE_FLOAT           : 4
TYPE_INT             : 3
error                : 

Nonterminals, with rules where they appear

type                 : 1 2
value                : 2
var_decl             : 0

Parsing method: LALR

state 0

    (0) S' -> . var_decl
    (1) var_decl -> . type ID SEMICOLON
    (2) var_decl -> . type ID ASSIGN value SEMICOLON
    (3) type -> . TYPE_INT
    (4) type -> . TYPE_FLOAT
    (5) type -> . TYPE_CHAR
    (6) type -> . TYPE_DOUBLE

    TYPE_INT        shift and go to state 5
    TYPE_FLOAT      shift and go to state 6
    TYPE_CHAR       shift and go to state 2
    TYPE_DOUBLE     shift and go to state 1

    type                           shift and go to state 4
    var_decl                       shift and go to state 3

state 1

    (6) type -> TYPE_DOUBLE .

    ID              reduce using rule 6 (type -> TYPE_DOUBLE .)


state 2

    (5) type -> TYPE_CHAR .

    ID              reduce using rule 5 (type -> TYPE_CHAR .)


state 3

    (0) S' -> var_decl .



state 4

    (1) var_decl -> type . ID SEMICOLON
    (2) var_decl -> type . ID ASSIGN value SEMICOLON

    ID              shift and go to state 7


state 5

    (3) type -> TYPE_INT .

    ID              reduce using rule 3 (type -> TYPE_INT .)


state 6

    (4) type -> TYPE_FLOAT .

    ID              reduce using rule 4 (type -> TYPE_FLOAT .)


state 7

    (1) var_decl -> type ID . SEMICOLON
    (2) var_decl -> type ID . ASSIGN value SEMICOLON

    SEMICOLON       shift and go to state 8
    ASSIGN          shift and go to state 9


state 8

    (1) var_decl -> type ID SEMICOLON .

    $end            reduce using rule 1 (var_decl -> type ID SEMICOLON .)


state 9

    (2) var_decl -> type ID ASSIGN . value SEMICOLON
    (7) value -> . INT
    (8) value -> . FLOAT
    (9) value -> . DOUBLE
    (10) value -> . CHAR
    (11) value -> . ID

    INT             shift and go to state 14
    FLOAT           shift and go to state 10
    DOUBLE          shift and go to state 11
    CHAR            shift and go to state 12
    ID              shift and go to state 13

    value                          shift and go to state 15

state 10

    (8) value -> FLOAT .

    SEMICOLON       reduce using rule 8 (value -> FLOAT .)


state 11

    (9) value -> DOUBLE .

    SEMICOLON       reduce using rule 9 (value -> DOUBLE .)


state 12

    (10) value -> CHAR .

    SEMICOLON       reduce using rule 10 (value -> CHAR .)


state 13

    (11) value -> ID .

    SEMICOLON       reduce using rule 11 (value -> ID .)


state 14

    (7) value -> INT .

    SEMICOLON       reduce using rule 7 (value -> INT .)


state 15

    (2) var_decl -> type ID ASSIGN value . SEMICOLON

    SEMICOLON       shift and go to state 16


state 16

    (2) var_decl -> type ID ASSIGN value SEMICOLON .

    $end            reduce using rule 2 (var_decl -> type ID ASSIGN value SEMICOLON .)

